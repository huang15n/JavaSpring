# Base de données, entité, référentiel, et service.

### Interface directe avec la base de données

Nous interfacer directement avec la base de donnée.  
Nous allons donc créer un nouveau table dans Mysql et créer une nouvelle classe en Java.  
Java mappe vers Mysql via ORM ou le mapper relationnel d'objet.

Le ORM est par defaut sur Spring Boot est Hibernate qui est celui que nous utiliserons.  
Nous allons plonger en profondeur discussions sur ORM plus tart.

Pour l'instant, vous avez juste besoin de qu'il relie une classe java à une table dans MySQL qu'il permet les lectures et écriture dans la base de donée.

### Organisation et abstraction jusqu'à présent

- **Un contrôleur** :  
   Il écoute les requêtes que nous avons.

- **La couche de service (service layer)** :  
   C’est ici que réside la **logique métier (business layer)**.

- **Le référentiel (repository)** :  
   Il contient la manière dont nous effectuons les appels à la base de données.

- **Une entité (entity)** :  
   Un terme sophistiqué pour désigner une classe Java ou une table dans MySQL.

---

### À propos de la base de données

1. **Exécution manuelle** :  
   Nous allons exécuter manuellement nos scripts MySQL pour :

   - Créer une nouvelle table.
   - Propager cette table avec des données factices.

2. **Automatisation avec Spring Boot** :  
   Spring Boot peut automatiquement générer la requête MySQL et l'exécuter.  
   Nous aborderons cette méthode plus tard.

Pour l'instant, nous effectuons le processus manuellement afin de bien comprendre ce que nous faisons.

# @Entity, @Data, @Table(name=""), @Id, @GenerateValue(strategy = GenerationTyp.IDENTITY), @Colum(name='nom')

Réorganisons notre code pour une meilleure structure en utilisant des dossiers pour les services et les modèles. Créons une nouvelle classe Java et annotons-la avec @Entity, ce qui indique qu'elle est mappée à une table de base de données.

Définir la table: Utilisez l'annotation @Table(name="produit") pour spécifier que cette classe est mappée à une table MySQL nommée "produit".
Définir la clé primaire:
Annotez l'identifiant de la classe avec @Id pour indiquer qu'il s'agit de la clé primaire.
Utilisez @GeneratedValue(strategy = GenerationType.IDENTITY) pour que l'identifiant soit généré automatiquement, en commençant à 1.
Définir les colonnes:
Annotez chaque champ de la classe avec @Column et spécifiez le nom de la colonne dans MySQL. Par exemple, pour un champ id, utilisez @Column(name="id").
Utiliser Lombok:
Utilisez les annotations de Lombok telles que @Data pour générer automatiquement les getters, setters, et autres méthodes utilitaires.

```java


package tutoriel.nouvelle_application.mon_application.modele;

import jakarta.persistence.*;
import lombok.Data;
// import org.hibernate.annotations.Table; ne fonctionne pas

/**
 *
 * Vous utilisez Spring Boot 3.0.0.M4 qui, comme l'indique la version, est une
 * version milestone (intermédiaire) et non une version finale pour le futur
 * Spring Boot 3.
 * Spring Boot 3 utilise JakartaEE 9 comme base, ce qui implique un changement
 * de package. Vous avez donc raison d'utiliser le package jakarta.persistence
 * pour les annotations.
 *
 * Cependant, l'annotation @Table que vous utilisez provient de
 * org.hibernate.annotations,
 * et vous devez utiliser celle de jakarta.persistence.Table à la place.
 *
 * De manière similaire, cela s'applique aussi à @Id. Actuellement, vous
 * utilisez
 * celle de Spring Data et non celle de JPA. Vous devez importer celle de
 * jakarta.persistence.Id.
 *
 * @Data : Cette annotation Lombok génère automatiquement les méthodes getter,
 *       setter, equals, hashCode et toString.
 * @Entity : Spécifie que la classe est une entité JPA, mappée à une table dans
 *         la base de données.
 * @Table(name = "produit") : Indique que cette entité est mappée à une table
 *             nommée "produit".
 * @Id : Spécifie que le champ est une clé primaire de la table.
 * @GeneratedValue(strategy = GenerationType.IDENTITY) : Indique que la valeur
 *                          de la clé primaire est générée automatiquement par
 *                          la base de données.
 * @Column(name = "id") : Spécifie que ce champ correspond à une colonne nommée
 *              "id" dans la table.
 * @Column(name = "nom") : Spécifie que ce champ correspond à une colonne nommée
 *              "nom" dans la table.
 * @Column(name = "description") : Spécifie que ce champ correspond à une
 *              colonne nommée "description" dans la table.
 * @Column(name = "prix") : Spécifie que ce champ correspond à une colonne
 *              nommée "prix" dans la table.
 *
 */

// Pour utiliser l'annotation @Data, vous devez ajouter la dépendance Lombok.
@Data
@Entity
@Table(name = "produit")
public class Produit {
   /**
    *[ERROR] /Users/eddiehuang/Desktop/Formation Web/Java Spring/mon_application/src/main/java/tutoriel/nouvelle_application/mon_application/service/ProduitService.java:[8,60] tutoriel.nouvelle_application.mon_application.modele.Produit is not public in tutoriel.nouvelle_application.mon_application.modele; cannot be accessed from outside package
    si tu manque le mot de clé public
    */

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Integer id;

    @Column(name = "nom")
    private String nom;

    @Column(name = "description")
    private String description;

    @Column(name = "prix")
    private Double prix;
}


```

### Référentiel extends JpaRepository<NomDeClass, Long>, @Autowire, xxRepository.findAll(), List<NomDeClasse> variable = xxRepository.findAll();

1. **Création du Référentiel**

   - Créez une nouvelle interface appelée _Référentiel_.
   - Annoter cette interface pour indiquer à Spring Boot qu'elle représente un référentiel pour la base de données.
   - Étendez l'interface `JpaRepository<Produit, Integer>`.
     - Cette extension fournit un accès à des méthodes gratuites pour interagir avec la base de données.

```java
package tutoriel.referentiel;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

/**
 * L'annotation @Repository indique à Spring que cette interface
 * est un composant de type Référentiel (DAO). Cela signifie qu'elle
 * sera détectée automatiquement par le mécanisme de scan de composants de Spring.
 *
 * Cela rend également cette interface éligible à la gestion des exceptions spécifiques
 * aux opérations avec la base de données. Par exemple, les exceptions de JPA seront
 * converties en exceptions de Spring Data.
 */
@Repository
public interface ProduitReferentiel extends JpaRepository<Produit, Long> {

    /**
     * L'interface ProduitReferentiel étend JpaRepository.
     *
     * L'extension de JpaRepository fournit des méthodes prêtes à l'emploi pour manipuler
     * les entités de type Produit dans la base de données. Parmi ces méthodes, on trouve :
     *
     * - findAll() : Retourne une liste de tous les produits.
     * - findById(Long id) : Recherche un produit par son identifiant.
     * - save(Produit produit) : Ajoute ou met à jour un produit.
     * - deleteById(Long id) : Supprime un produit par son identifiant.
     *
     * Paramètres génériques de JpaRepository :
     * - Produit : le type de l'entité que le référentiel manipule.
     * - Long : le type de l'identifiant de l'entité.
     *
     * Cette interface peut également être étendue pour inclure des requêtes personnalisées
     * si nécessaire, en définissant des méthodes supplémentaires.
     */
}

```

2. **Utilisation du Service**
   - Dans le service, injectez le référentiel à l'aide de l'annotation `@Autowired`.
   - Une des méthodes gratuites fournies par `JpaRepository` est `findAll()`.
     - Cette méthode retourne une liste d'articles, qui peut être utilisée comme suit :  
       `List<NomDeClasse> articles = xxxReferentiel.findAll();`

```java

package tutoriel.nouvelle_application.mon_application.service;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import tutoriel.nouvelle_application.mon_application.modele.Produit;
import tutoriel.nouvelle_application.mon_application.referentiel.ProduitReferentiel;


@Service
public class ProduitService {

    private final ProduitReferentiel produitReferentiel;

    @Autowired
    public ProduitService(ProduitReferentiel produitReferentiel) {
        this.produitReferentiel = produitReferentiel;

    }
    // @Override
    // public String creer(Long id) {
    //     return "Produit créé avec succès : " + id;
    // }

    // @Override
    // public String supprimer(Long id) {
    //     return "Produit supprimé avec succès : " + id;
    // }


    public List<Produit> obtenir() {
        List<Produit> resultat = produitReferentiel.findAll();
        return resultat;
        // pas du conversion est necessaire
    }

    /***
     *
     * ERROR] Errors:
     * [ERROR] MonApplicationTests.contextLoads » IllegalState Failed to load
     * ApplicationContext for [WebMergedContextConfiguration@1299c874 testClass =
     * tutoriel.nouvelle_application.mon_application.MonApplicationTests, locations
     * = [], classes =
     * [tutoriel.nouvelle_application.mon_application.MonApplication],
     * contextInitializerClasses = [], activeProfiles = [],
     * propertySourceDescriptors = [], propertySourceProperties =
     * ["org.springframework.boot.test.context.SpringBootTestContextBootstrapper=true"],
     * contextCustomizers =
     * [org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@1349883,
     * org.springframework.boot.tes
     *
     *
     *
     *
     * [ERROR] /Users/eddiehuang/Desktop/Formation Web/Java
     * Spring/mon_application/src/main/java/tutoriel/nouvelle_application/mon_application/service/ProduitService.java:[10,28]
     * package tutoriel.referentiel does not exist
     * [ERROR] /Users/eddiehuang/Desktop/Formation Web/Java
     * Spring/mon_application/src/main/java/tutoriel/nouvelle_application/mon_application/service/ProduitService.java:[15,19]
     * cannot find symbol
     * symbol: class ProduitReferentiel
     * location: class
     * tutoriel.nouvelle_application.mon_application.service.ProduitService
     * [ERROR] /Users/eddiehuang/Desktop/Formation Web/Java
     * Spring/mon_application/src/main/java/tutoriel/nouvelle_application/mon_application/service/ProduitService.java:[18,27]
     * cannot find symbol
     * symbol: class ProduitReferentiel
     * location: class
     * tutoriel.nouvelle_application.mon_application.service.ProduitService
     * [INFO] 3 errors
     * assurer votre doissier est dans la meme structure d'autre
     */

    // @Override
    // public String modifier(String produit) {
    //     return "Produit modifié avec succès : " + produit;
    // }
}



/**
 *
 * : 42S02
2024-11-25T17:33:15.136-05:00 ERROR 57860 --- [mon_application] [nio-8080-exec-8] o.h.engine.jdbc.spi.SqlExceptionHelper   : Table 'nouvelle_application.produit' doesn't exist
2024-11-25T17:33:15.139-05:00 ERROR 57860 --- [mon_application] [nio-8080-exec-8] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: org.springframework.dao.InvalidDataAccessResourceUsageException: JDBC exception executing SQL [select p1_0.id,p1_0.description,p1_0.nom,p1_0.prix from produit p1_0] [Table 'nouvelle_application.produit' doesn't exist] [n/a]; SQL [n/a]] with root cause

 * /

```

nous devons configurer notre base de données, alors dirigez-vous vers mysql et executez ces trois scripts afin que vous voulez lui dire laquelle vous utlisez, alors nous voulons creer notre table de

```sql

USE nouvelle_application;

CREATE TABLE IF NOT EXISTS produit (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nom VARCHAR(255),
    description TEXT,
    prix DECIMAL(10, 2)
);


-- Insérer des données fictives dans la table produit
INSERT INTO produit (nom, description, prix)
VALUES
    ('Produit 1', 'Description aléatoire de produit 1', ROUND(RAND() * 100, 2)),
    ('Produit 2', 'Description aléatoire de produit 2', ROUND(RAND() * 100, 2)),
    ('Produit 3', 'Description aléatoire de produit 3', ROUND(RAND() * 100, 2)),
    ('Produit 4', 'Description aléatoire de produit 4', ROUND(RAND() * 100, 2)),
    ('Produit 5', 'Description aléatoire de produit 5', ROUND(RAND() * 100, 2)),
    ('Produit 6', 'Description aléatoire de produit 6', ROUND(RAND() * 100, 2)),
    ('Produit 7', 'Description aléatoire de produit 7', ROUND(RAND() * 100, 2)),
    ('Produit 8', 'Description aléatoire de produit 8', ROUND(RAND() * 100, 2)),
    ('Produit 9', 'Description aléatoire de produit 9', ROUND(RAND() * 100, 2)),
    ('Produit 10', 'Description aléatoire de produit 10', ROUND(RAND() * 100, 2));

```

## code

```java
package com.eddie.produit.contrat;

import org.springframework.http.ResponseEntity;

public interface Chercher <I,O>{

    ResponseEntity<O> executer();

}

package com.eddie.produit.contrat;

import org.springframework.http.ResponseEntity;

public interface Commande <I,O>{
    ResponseEntity<O> executer(I input);

}
package com.eddie.produit.controlleur;


import com.eddie.produit.modele.Produit;
import com.eddie.produit.service.*;
import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
public class ProduitControlleur {


    private final ChercherService chercherService;
    private final ModifierService modifierService;
    private final SupprimerService supprimerService;
    private final AjouterService ajouterService;


    @Autowired
    public ProduitControlleur(ChercherService chercherService, ModifierService modifierService, SupprimerService supprimerService, AjouterService ajouterService) {
        this.chercherService = chercherService;
        this.modifierService = modifierService;
        this.supprimerService = supprimerService;
        this.ajouterService = ajouterService;
    }





    @RequestMapping("rechercher")
    public ResponseEntity<List<Produit>> rechercher(){
        return this.chercherService.executer();
    }

    @RequestMapping("ajouter")
    public ResponseEntity<String> ajouter(){
        return this.ajouterService.executer(null);
    }

    @RequestMapping("modifier")
    public ResponseEntity<String> modifier(){
        return this.modifierService.executer(null);
    }

    @RequestMapping("supprimer")
    public ResponseEntity<String> supprimer(){
        return this.supprimerService.executer(null);
    }



}

package com.eddie.produit.modele;


import jakarta.persistence.*;
import lombok.Data;

@Entity
@Table(name="produit")
@Data
public class Produit {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Integer id;

    @Column(name = "nom")
    private String nom;

    @Column(name = "description")
    private String description;

    @Column(name = "prix")
    private Double prix;


}

package com.eddie.produit.referentielle;

import com.eddie.produit.modele.Produit;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface ProduitReferentielle  extends JpaRepository<Produit, Long> {
}

package com.eddie.produit.service;


import com.eddie.produit.contrat.Commande;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

@Service
public class AjouterService implements Commande<Void, String> {


    @Override
    public ResponseEntity<String> executer(Void input){
        return ResponseEntity.status(HttpStatus.CREATED).body("ajouter");
    }
}
package com.eddie.produit.service;


import com.eddie.produit.contrat.Chercher;
import com.eddie.produit.modele.Produit;
import com.eddie.produit.referentielle.ProduitReferentielle;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class ChercherService implements Chercher<Void, List<Produit>> {

    private final ProduitReferentielle produitReferentielle;

    @Autowired
     public ChercherService(ProduitReferentielle produitReferentielle) {
        this.produitReferentielle = produitReferentielle;
    }

    @Override
    public ResponseEntity<List<Produit>> executer() {
        List<Produit> produits =this.produitReferentielle.findAll();
        return ResponseEntity.status(HttpStatus.OK).body(produits);

    }
}
package com.eddie.produit.service;


import com.eddie.produit.contrat.Commande;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

@Service
public class ModifierService implements Commande<Void, String> {


    @Override
    public ResponseEntity<String> executer(Void input) {
       return ResponseEntity.status(HttpStatus.OK).body("modifier");
    }


}
package com.eddie.produit.service;


import com.eddie.produit.contrat.Commande;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

@Service
public class SupprimerService implements Commande<Void, String> {


    @Override
    public ResponseEntity<String> executer(Void input){
        return ResponseEntity.status(HttpStatus.NO_CONTENT).body("supprimer");
    }
}

```

---

# Tous CRUD

Nous avons maintenant notre premier exemple de référentiel en cours d'exécution.

Nous sommes prêts à explorer toutes les opérations CRUD, qui signifient : créer, lire, mettre à jour et supprimer.

Voici un tableau décrivant les comportements des requêtes HTTP `POST`, `PUT`, `GET`, et `DELETE` en fonction des spécifications données :

| **Méthode** | **Corps de la requête (Request Body)** | **URL**         | **ID requis** | **Statut de la réponse (Response Status)** | **Corps de la réponse (Response Body)**                                     |
| ----------- | -------------------------------------- | --------------- | ------------- | ------------------------------------------ | --------------------------------------------------------------------------- |
| **POST**    | `Produit`                              | `/produit`      | Non           | `201 Created`                              | `ProduitDTO` (optionnel), qui pourrait contenir suffisamment d'informations |
| **PUT**     | `Produit`                              | `/produit/{id}` | Oui           | `200 OK`                                   | `ProduitDTO` (optionnel)                                                    |
| **GET**     | Aucun                                  | `/produit/{id}` | Oui           | `200 OK`                                   | `ProduitDTO`                                                                |
| **DELETE**  | Aucun                                  | `/produit/{id}` | Oui           | `204 No Content`                           | Aucun                                                                       |

### Détails supplémentaires :

1. **POST** :

   - Utilisé pour créer un nouveau produit.
   - Ne nécessite pas d'ID dans la requête, car un nouvel ID sera généré automatiquement.
   - La réponse peut inclure les détails du produit créé sous forme de `ProduitDTO`. il est logique d'aller de l'avant et de renvoyer DTO immédiateent , de cette façon, vous pourrez l'utiliser ensuite.

2. **PUT** :

   - Utilisé pour mettre à jour un produit existant.
   - Nécessite un ID dans l'URL pour identifier le produit à mettre à jour.
   - La réponse peut inclure les détails mis à jour du produit sous forme de `ProduitDTO`.

3. **GET** :

   - Utilisé pour récupérer les informations d'un produit spécifique.
   - Nécessite un ID dans l'URL pour identifier le produit à récupérer.
   - La réponse inclut les détails du produit sous forme de `ProduitDTO`.

4. **DELETE** :
   - Utilisé pour supprimer un produit.
   - Nécessite un ID dans l'URL pour identifier le produit à supprimer.
   - La réponse ne contient aucun corps et renvoie un statut `204 No Content`.

# DTO or Response Object

Essentiellement, nous ne voulons pas renvoyer l'objet entier. Certaines tables peuvent contenir jusqu'à 80 colonnes ou plus, ce qui rendrait l'objet trop volumineux pour être utile. C'est pourquoi nous utilisons un DTO (Data Transfer Object), qui renvoie uniquement les données nécessaires pour un point de terminaison spécifique.

Ce que nous devons faire, c'est récupérer un produit depuis la base de données, le convertir en un objet DTO, puis renvoyer ce DTO à l'interface utilisateur. C'est un peu similaire à une projection, bien que ce ne soit pas exactement la même chose.

En résumé, nous prenons un produit, ignorons les champs inutiles, créons un DTO avec les données pertinentes, et l'envoyons à l'utilisateur.

Créez une nouvelle classe appelée `xxDTO`. Cette classe jouera le rôle de **Data Transfer Object (DTO)**, utilisée pour transférer uniquement les données nécessaires entre les différentes couches de l'application. Elle exclut les champs inutiles de l'objet d'origine afin d'optimiser les échanges avec l'interface utilisateur ou d'autres systèmes.

```java
package tutoriel.nouvelle_application.mon_application.modele;

import lombok.Data;

@Data
public class ProduitDTO {

    private Integer id;
    private String nom;
    private String description;


    public ProduitDTO(Produit produit) {
        this.id = produit.getId();
        this.nom = produit.getNom();
        this.description = produit.getDescription();

    }

}


```

# Création d’une API CRUD en Spring Boot

La logique pour créer un système CRUD (Éléments de base : Créer, Lire, Mettre à jour et Supprimer) en utilisant Spring Boot, en se basant sur la structure et le code fourni.

---

## 1. Modélisation des entités

L’entité principale est `Produit`, qui représente un produit stocké dans une base de données. Cette entité est annotée avec `@Entity` et contient les champs suivants :

- **id** : Identifiant unique pour chaque produit.
- **nom** : Nom du produit.
- **description** : Détails sur le produit.
- **prix** : Coût du produit.

Chaque champ est mappé à une colonne de la table de base de données grâce à l’annotation `@Column`.

Voici une explication des annotations et concepts mentionnés dans le code :

---

### **1. @Entity**

L'annotation `@Entity` indique à JPA (Java Persistence API) que la classe correspond à une entité, c'est-à-dire une table dans une base de données. Chaque instance de cette classe représente une ligne dans la table correspondante.

- **Dans votre code :**
  ```java
  @Entity
  @Table(name="produit")
  public class Produit { ... }
  ```
  La classe `Produit` est une entité JPA et sera mappée à la table `produit` dans la base de données.

---

### **2. @Table**

L'annotation `@Table` permet de personnaliser le nom de la table ou d'ajouter d'autres informations sur la façon dont JPA gère cette entité dans la base de données.

- **Attributs courants :**

  - `name` : Spécifie le nom de la table. Si cette annotation est omise, JPA utilise le nom de la classe par défaut.
  - Autres options (non utilisées ici) : `schema`, `catalog`, etc.

- **Dans votre code :**
  ```java
  @Table(name="produit")
  ```
  Cela indique que cette entité est mappée à une table nommée **`produit`** dans la base de données.

---

### **3. @GeneratedValue(strategy = GenerationType.IDENTITY)**

L'annotation `@GeneratedValue` est utilisée pour spécifier la stratégie de génération des valeurs pour une clé primaire.

- **Clé primaire automatique :**

  - L'attribut `strategy` définit la stratégie utilisée pour générer la valeur.
  - Avec `GenerationType.IDENTITY`, la base de données gère automatiquement la génération des valeurs (souvent des incréments automatiques pour les colonnes ID).

- **Pourquoi `IDENTITY` ?**
  - Cela convient lorsque la base de données elle-même (ex. MySQL, PostgreSQL) est configurée pour gérer les clés primaires en auto-incrément.
  - Aucun séquenceur ou table supplémentaire n'est nécessaire côté JPA.

##### Vous utilisez @GeneratedValue(strategy = GenerationType.AUTO). Cela peut poser des problèmes selon le type de base de données : Avec MySQL, la stratégie AUTO utilise généralement IDENTITY, mais il est recommandé d'utiliser explicitement GenerationType.IDENTITY pour éviter des conflits ou des séquences manquantes. @GeneratedValue(strategy = GenerationType.IDENTITY)

sinon quand tu POST ton data, cela affiche

```

work.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:223) ~[spring-aop-6.2.0.jar:6.2.0]
	at jdk.proxy2/jdk.proxy2.$Proxy117.save(Unknown Source) ~[na:na]
	at com.eddie.produit.service.AjouterService.executer(AjouterService.java:23) ~[classes/:na]
	at com.eddie.produit.controlleur.ProduitControlleur.ajouter(ProduitControlleur.java:47) ~[classes/:na]
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[na:na]
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]
	at java.base/java.lang.reflect.Method.invoke(Method.java:568) ~[na:na]
```

```java
package com.eddie.produit.modele;


import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Data;

@Entity
@Table(name="produit")
@Data
public class Produit {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Integer id;

    @Column(name = "nom")
    private String nom;

    @Column(name = "description")
    private String description;

    @Column(name = "prix")
    private Double prix;


}

```

Voici votre code avec des commentaires détaillés pour expliquer chaque ligne et pourquoi cette classe est nécessaire :

```java
package com.eddie.produit.modele;

import lombok.Getter;

// L'annotation @Getter de Lombok génère automatiquement les méthodes "getter"
// pour toutes les variables de classe (id et produit). Cela réduit le code boilerplate
// et permet un accès facile à ces variables dans d'autres parties du programme.
@Getter
public class ProduitAjouterCommande {

    // Variable id pour identifier l'entité produit que l'on souhaite modifier ou ajouter.
    // Cette clé est importante pour savoir quel produit est ciblé lors d'une commande spécifique.
    private Integer id;

    // L'objet Produit contient les détails du produit à ajouter ou mettre à jour.
    // Cela rend la classe flexible pour transmettre à la fois une référence à un produit et ses données.
    private Produit produit;

    // Constructeur de la classe ProduitAjouterCommande.
    // Il est utilisé pour initialiser les deux propriétés nécessaires (id et produit) lors de la création d'une commande.
    public ProduitAjouterCommande(Integer id, Produit produit) {
        // Assigne la valeur d'id à l'attribut id de la classe.
        this.id = id;
        // Assigne l'objet Produit passé en paramètre à l'attribut produit de la classe.
        this.produit = produit;
    }
}
```

---

### **Pourquoi cette classe est nécessaire ?**

1. **Structure et Clarté :**  
   La classe `ProduitAjouterCommande` agit comme un **wrapper** pour transmettre les informations nécessaires pour une commande d'ajout ou de modification d'un produit. Elle regroupe les données `id` et `produit` en une seule entité logique, ce qui facilite le passage de données dans les services.

2. **Réutilisabilité :**

   - Cette classe peut être utilisée dans différentes parties du code pour toutes les opérations nécessitant un `id` (comme pour identifier un produit existant) et un objet `Produit` (pour contenir les nouvelles données).
   - Par exemple, dans un service de mise à jour, vous pouvez utiliser cette classe pour modifier un produit existant.

3. **Simplifie le traitement des commandes :**  
   Au lieu de passer plusieurs paramètres à chaque méthode (comme un entier pour l'id et un objet pour les données), cette classe encapsule tout en un seul objet. Cela rend le code plus lisible et plus facile à maintenir.

4. **Compatibilité avec les architectures modernes :**  
   Dans une application de type REST ou utilisant des DTO (Data Transfer Objects), ce genre de classe est pratique pour représenter une charge utile (**payload**) lors de la réception ou l'envoi de données.

5. **Préparation aux validations :**
   - Avec cette structure, vous pouvez facilement ajouter des validations spécifiques à la classe (par exemple, vérifier si l'`id` n'est pas nul).
   - Cela garantit que les données transmises sont valides avant leur traitement dans les services.

---

## 2. Création des DTO (Data Transfer Object)

Un DTO (`ProduitDTO`) est utilisé pour transférer des données entre différentes couches de l’application sans exposer directement l’entité. Cela permet :

- D’améliorer la sécurité et l’isolation des données.
- De simplifier les réponses envoyées au client (par exemple, exclusion de champs sensibles).

Le constructeur du DTO transforme un objet `Produit` en objet `ProduitDTO`.

---

```java

package com.eddie.produit.DTO;

import com.eddie.produit.modele.Produit;
import lombok.Data;

@Data
public class ProduitDTO {

    private Integer id;
    private String nom;
    private String description;

    public ProduitDTO(Produit produit) {
        this.id = produit.getId();
        this.nom = produit.getNom();
        this.description = produit.getDescription();
    }
}

```

## 3. Référentiel (Repository)

Le référentiel `ProduitReferentielle` (étendu de `JpaRepository`) permet d’effectuer des opérations sur la base de données sans écrire de requêtes SQL manuelles.

### Fonctions clés incluses :

- `save()` : Enregistrer ou mettre à jour un produit.
- `findById()` : Récupérer un produit par son ID.
- `findAll()` : Récupérer tous les produits.
- `deleteById()` : Supprimer un produit.

### Exemple avec `ProduitReferentielle`

```java
package com.eddie.produit.referentielle;

import com.eddie.produit.modele.Produit;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

/**
 * Interface référentielle pour gérer les opérations de base sur la base de données.
 * Hérite de JpaRepository pour fournir des méthodes CRUD prêtes à l'emploi.
 */
@Repository // Indique que cette interface est un composant Spring pour l'accès aux données.
public interface ProduitReferentielle extends JpaRepository<Produit, Long> {
}
```

---

## 4. Services pour les opérations CRUD

Les services implémentent la logique métier et s’appuient sur le référentiel pour interagir avec la base de données. Chaque service correspond à une opération CRUD.

### a) Création (`AjouterService`)

- Reçoit un objet `Produit` via une requête.
- Utilise `produitReferentielle.save()` pour sauvegarder le produit.
- Retourne un objet `ProduitDTO` avec un statut HTTP **201 (Created)**.

```java

package com.eddie.produit.service;

import com.eddie.produit.DTO.ProduitDTO;
import com.eddie.produit.contrat.Commande;
import com.eddie.produit.modele.Produit;
import com.eddie.produit.referentielle.ProduitReferentielle;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

@Service // Annotation Spring qui indique que cette classe est un service métier.
public class AjouterService implements Commande<Produit, ProduitDTO> {

    private ProduitReferentielle produitReferentielle;

    // Injection de dépendance pour accéder au référentiel des produits.
    public AjouterService(ProduitReferentielle produitReferentielle) {
        this.produitReferentielle = produitReferentielle;
    }

    @Override
    public ResponseEntity<ProduitDTO> executer(Produit produit) {
        // Sauvegarde le produit dans la base de données via le référentiel.
        Produit produitAjoute = produitReferentielle.save(produit);

        // Retourne une réponse avec un statut HTTP 201 (Créé) et le DTO du produit ajouté.
        return ResponseEntity.status(HttpStatus.CREATED).body(new ProduitDTO(produitAjoute));
    }
}

```

### b) Lecture de tous les produits (`ChercherService`)

- Récupère tous les produits avec `findAll()`.
- Convertit la liste en `ProduitDTO` grâce à un flux (élégant avec `.stream().map().toList()`).
- Retourne les produits avec un statut HTTP **200 (OK)**.

```java
package com.eddie.produit.service;

import com.eddie.produit.DTO.ProduitDTO;
import com.eddie.produit.contrat.Chercher;
import com.eddie.produit.modele.Produit;
import com.eddie.produit.referentielle.ProduitReferentielle;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.util.List;

@Service // Classe annotée comme un service géré par Spring.
public class ChercherService implements Chercher<Void, List<ProduitDTO>> {

    private final ProduitReferentielle produitReferentielle;

    @Autowired // Injection de dépendance pour le référentiel.
    public ChercherService(ProduitReferentielle produitReferentielle) {
        this.produitReferentielle = produitReferentielle;
    }

    @Override
    public ResponseEntity<List<ProduitDTO>> executer() {
        // Récupère tous les produits depuis le référentiel.
        List<Produit> produits = this.produitReferentielle.findAll();

        // Transforme chaque produit en DTO pour l'envoi de la réponse.
        List<ProduitDTO> produitDTOs = produits.stream().map(ProduitDTO::new).toList();

        // Retourne une réponse HTTP 200 avec la liste des produits.
        return ResponseEntity.status(HttpStatus.OK).body(produitDTOs);
    }
}


```

### c) Lecture d’un produit par ID (`ChercherUnArticleService`)

- Récupère un produit spécifique avec `findById()`.
- Si présent, retourne un `ProduitDTO` et le statut **200 (OK)**. Sinon, retourne une réponse vide ou une erreur.

```java

package com.eddie.produit.service;

import com.eddie.produit.DTO.ProduitDTO;
import com.eddie.produit.contrat.Commande;
import com.eddie.produit.modele.Produit;
import com.eddie.produit.referentielle.ProduitReferentielle;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.util.Optional;

@Service // Annotation indiquant que cette classe gère une logique métier.
public class ChercherUnArticleService implements Commande<Integer, ProduitDTO> {

    private final ProduitReferentielle produitReferentielle;

    public ChercherUnArticleService(ProduitReferentielle produitReferentielle) {
        this.produitReferentielle = produitReferentielle;
    }

    @Override
    public ResponseEntity<ProduitDTO> executer(Integer id) {
        // Recherche le produit par son ID dans la base de données.
        Optional<Produit> produitOptionel = this.produitReferentielle.findById(Long.valueOf(id));

        // Si le produit est trouvé, renvoyer une réponse HTTP 200 avec le DTO du produit.
        if (produitOptionel.isPresent()) {
            return ResponseEntity.status(HttpStatus.OK).body(new ProduitDTO(produitOptionel.get()));
        }

        // Sinon, retourne null (à remplacer par une gestion d'erreur améliorée).
        return null;
    }
}

```

### d) Mise à jour (`ModifierService`)

- Reçoit un ID et un objet `Produit` encapsulés dans `ProduitAjouterCommande`.
- Récupère le produit existant avec `getReferenceById()`.
- Met à jour ses champs, puis l’enregistre via `save()`.
- Retourne un `ProduitDTO` et un statut **200 (OK)**.

```java

package com.eddie.produit.service;

import com.eddie.produit.DTO.ProduitDTO;
import com.eddie.produit.contrat.Commande;
import com.eddie.produit.modele.Produit;
import com.eddie.produit.modele.ProduitAjouterCommande;
import com.eddie.produit.referentielle.ProduitReferentielle;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.util.Optional;

@Service // Cette classe gère les mises à jour de produits.
public class ModifierService implements Commande<ProduitAjouterCommande, ProduitDTO> {

    private final ProduitReferentielle produitReferentielle;

    public ModifierService(ProduitReferentielle produitReferentielle) {
        this.produitReferentielle = produitReferentielle;
    }

    @Override
    public ResponseEntity<ProduitDTO> executer(ProduitAjouterCommande produitAjouterCommande) {
        // Recherche le produit par ID dans le référentiel.
        Optional<Produit> produitOptionel = Optional.of(produitReferentielle.getReferenceById(Long.valueOf(produitAjouterCommande.getId())));

        // Si le produit est trouvé, effectue la mise à jour.
        if (produitOptionel.isPresent()) {
            Produit produit = produitAjouterCommande.getProduit();
            produit.setId(produitAjouterCommande.getId());
            produitReferentielle.save(produit);

            // Retourne une réponse HTTP 200 avec le produit mis à jour.
            return ResponseEntity.ok(new ProduitDTO(produit));
        }

        // Sinon, retourne null (à remplacer par une meilleure gestion d'erreur).
        return null;
    }
}

```

### e) Suppression (`SupprimerService`)

- Supprime un produit via son ID avec `deleteById()`.
- Retourne un statut HTTP **204 (No Content)** si la suppression est réussie.

```java

package com.eddie.produit.service;

import com.eddie.produit.contrat.Commande;
import com.eddie.produit.modele.Produit;
import com.eddie.produit.referentielle.ProduitReferentielle;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.util.Optional;

@Service // Service responsable de la suppression des produits.
public class SupprimerService implements Commande<Integer, Void> {

    private final ProduitReferentielle produitReferentielle;

    public SupprimerService(ProduitReferentielle produitReferentielle) {
        this.produitReferentielle = produitReferentielle;
    }

    @Override
    public ResponseEntity<Void> executer(Integer id) {
        // Recherche le produit par ID.
        Optional<Produit> produitOptionel = produitReferentielle.findById(Long.valueOf(id));

        // Si le produit existe, il est supprimé.
        if (produitOptionel.isPresent()) {
            produitReferentielle.deleteById(Long.valueOf(id));

            // Retourne une réponse HTTP 204 (Pas de contenu).
            return ResponseEntity.status(HttpStatus.NO_CONTENT).build();
        }

        // Sinon, retourne null (à remplacer par une gestion d'erreur adéquate).
        return null;
    }
}

```

---

## 5. Implémentation des interfaces génériques

Des interfaces génériques comme `Commande` et `Chercher` définissent des méthodes standard pour les services, rendant le code plus modulaire et facilement extensible.

---

Cette architecture suit les bonnes pratiques de conception de Spring Boot, notamment :

- Séparation claire des responsabilités.
- Utilisation des DTO pour la sécurité et la simplicité.
- Découplage des couches grâce aux interfaces et aux annotations Spring.
- Génération automatique de méthodes CRUD grâce à JPA.

### Interface Chercher

```java
package com.eddie.produit.contrat;

import org.springframework.http.ResponseEntity;

/**
 * Interface générique pour une opération de recherche sans entrée.
 * @param <I> Type d'entrée (non utilisé ici, toujours Void).
 * @param <O> Type de sortie (par exemple, DTO ou liste d'objets).
 */
public interface Chercher<I, O> {

    /**
     * Exécute l'opération de recherche et retourne un objet encapsulé dans une ResponseEntity.
     * @return ResponseEntity contenant l'objet résultat.
     */
    ResponseEntity<O> executer();
}
```

---

### Interface Commande

```java
package com.eddie.produit.contrat;

import org.springframework.http.ResponseEntity;

/**
 * Interface générique pour une commande qui prend une entrée et retourne une réponse.
 * @param <I> Type de l'entrée (par exemple, un objet produit).
 * @param <O> Type de la sortie (par exemple, un DTO).
 */
public interface Commande<I, O> {

    /**
     * Exécute la commande avec les données fournies.
     * @param input Données d'entrée nécessaires pour traiter la commande.
     * @return ResponseEntity contenant l'objet résultat ou un état.
     */
    ResponseEntity<O> executer(I input);
}
```

---

---

## 6. Controlleur

### Contrôleur ProduitControlleur

Le contrôleur `ProduitControlleur` est une classe REST qui gère les endpoints pour effectuer des opérations CRUD (Create, Read, Update, Delete) sur les produits. Il utilise des services pour déléguer la logique métier, garantissant ainsi une séparation claire entre la présentation et le traitement des données.

#### Points clés de `ProduitControlleur` :

1. **Annotations** :

   - `@RestController` : Déclare la classe comme un contrôleur REST qui gère les requêtes HTTP et renvoie des réponses JSON.
   - `@GetMapping`, `@PostMapping`, `@PutMapping`, et `@DeleteMapping` : Définissent les routes associées aux opérations CRUD et le type de requête HTTP correspondant.

2. **Injection des Services** :

   - `ChercherService` : Pour récupérer tous les produits.
   - `ChercherUnArticleService` : Pour récupérer un produit spécifique.
   - `AjouterService` : Pour ajouter un nouveau produit.
   - `ModifierService` : Pour mettre à jour un produit existant.
   - `SupprimerService` : Pour supprimer un produit.

   Ces services permettent de maintenir une logique métier bien organisée et testable.

3. **Endpoints CRUD exposés** :

   - **Rechercher tous les produits** :

     - **Route** : `/produits`
     - **Méthode** : `GET`
     - **Service utilisé** : `ChercherService`
     - **Description** : Retourne une liste de tous les produits sous forme de `ProduitDTO`.

   - **Rechercher un produit spécifique** :

     - **Route** : `/produit/{id}`
     - **Méthode** : `GET`
     - **Service utilisé** : `ChercherUnArticleService`
     - **Description** : Retourne les détails d’un produit correspondant à l’`id`.

   - **Ajouter un produit** :

     - **Route** : `/produit`
     - **Méthode** : `POST`
     - **Service utilisé** : `AjouterService`
     - **Description** : Crée un nouveau produit à partir des données fournies dans le corps de la requête.

   - **Modifier un produit existant** :

     - **Route** : `/produit/{id}`
     - **Méthode** : `PUT`
     - **Service utilisé** : `ModifierService`
     - **Description** : Met à jour un produit existant identifié par l’`id` avec les nouvelles informations fournies.

   - **Supprimer un produit** :
     - **Route** : `/produit/{id}`
     - **Méthode** : `DELETE`
     - **Service utilisé** : `SupprimerService`
     - **Description** : Supprime un produit existant correspondant à l’`id`.

4. **Utilisation des objets `ResponseEntity`** :

   - Chaque méthode retourne une instance de `ResponseEntity`, permettant de configurer le statut HTTP et de fournir une réponse claire au client.

5. **Avantages** :
   - Séparation des responsabilités : Le contrôleur se concentre uniquement sur les requêtes/réponses HTTP, tandis que les services gèrent la logique métier.
   - Maintenabilité : Chaque service peut être testé et modifié indépendamment.
   - Lisibilité : Les annotations et la structure facilitent la compréhension rapide des fonctionnalités exposées.

```java
package com.eddie.produit.controlleur;

import com.eddie.produit.DTO.ProduitDTO;
import com.eddie.produit.modele.Produit;
import com.eddie.produit.modele.ProduitAjouterCommande;
import com.eddie.produit.service.*;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * Contrôleur REST pour exposer les endpoints CRUD du produit.
 * Utilise des services pour gérer la logique métier.
 */
@RestController // Déclare cette classe comme un contrôleur REST gérant les requêtes HTTP.
public class ProduitControlleur {

    // Services injectés pour gérer différentes opérations CRUD.
    private final ChercherService chercherService;
    private final ModifierService modifierService;
    private final SupprimerService supprimerService;
    private final AjouterService ajouterService;
    private final ChercherUnArticleService chercherUnArticleService;

    /**
     * Constructeur avec injection des services nécessaires.
     */
    public ProduitControlleur(ChercherService chercherService, ModifierService modifierService,
                              SupprimerService supprimerService, AjouterService ajouterService,
                              ChercherUnArticleService chercherUnArticleService) {
        this.chercherService = chercherService;
        this.modifierService = modifierService;
        this.supprimerService = supprimerService;
        this.ajouterService = ajouterService;
        this.chercherUnArticleService = chercherUnArticleService;
    }

    @GetMapping("/produits") // Mappe cette méthode à l'endpoint HTTP GET /produits.
    public ResponseEntity<List<ProduitDTO>> rechercher() {
        return this.chercherService.executer(); // Appelle le service pour récupérer tous les produits.
    }

    @GetMapping("/produit/{id}") // Mappe cette méthode à l'endpoint HTTP GET /produit/{id}.
    public ResponseEntity<ProduitDTO> rechercherUnArticle(@PathVariable Integer id) {
        return this.chercherUnArticleService.executer(id); // Appelle le service pour un produit spécifique.
    }

    @PostMapping("/produit") // Mappe cette méthode à l'endpoint HTTP POST /produit.
    public ResponseEntity<ProduitDTO> ajouter(@RequestBody Produit produit) {
        return this.ajouterService.executer(produit); // Appelle le service pour ajouter un produit.
    }

    @PutMapping("/produit/{id}") // Mappe cette méthode à l'endpoint HTTP PUT /produit/{id}.
    public ResponseEntity<ProduitDTO> modifier(@PathVariable Integer id, @RequestBody Produit produit) {
        return this.modifierService.executer(new ProduitAjouterCommande(id, produit)); // Appelle le service pour modifier un produit.
    }

    @DeleteMapping("/produit/{id}") // Mappe cette méthode à l'endpoint HTTP DELETE /produit/{id}.
    public ResponseEntity<Void> supprimer(@PathVariable Integer id) {
        return this.supprimerService.executer(id); // Appelle le service pour supprimer un produit.
    }
}
```

---

## stream().map(NomDeClass::getMethode()).toList()

Voici les concepts associés à l'expression `stream().map(NomDeClass::getMethode()).toList()` :

1. **`stream()`** :

   - Crée un flux à partir d'une collection (comme une liste, un ensemble, etc.) pour permettre un traitement fonctionnel des éléments.

2. **`map()`** :

   - Transformation des éléments d'un flux. Chaque élément est transformé en une nouvelle valeur selon la fonction fournie. Cela génère un nouveau flux avec les résultats de la transformation.
   - **Méthode de référence** (`NomDeClass::getMethode`) : Utilisation d'une méthode existante pour appliquer la transformation à chaque élément. Ici, `getMethode()` est une méthode d'instance de la classe `NomDeClass`.

3. **Méthode de référence** :

   - Remplace une expression lambda par une référence à une méthode, simplifiant ainsi l'écriture du code. Par exemple, `NomDeClass::getMethode` est une référence à la méthode `getMethode()` de la classe `NomDeClass`.

4. **`toList()`** :
   - Collecte les éléments du flux dans une liste. Cette opération terminale permet de récupérer les éléments après les avoir transformés par `map()`. Il existe d'autres collecteurs comme `toSet()` ou `joining()`, mais ici `toList()` est utilisé pour créer une liste.

## Optional <TypeOuClasse> nomDeVariable = value;

Optional est une classe conteneur utilisée pour représenter une valeur qui peut être présente ou absente. Elle permet d'éviter les exceptions de type NullPointerException en offrant des méthodes pour manipuler les valeurs potentiellement nulles de manière sûre.

Voici un aperçu général de son fonctionnement :

Optional.empty() : Crée un Optional vide, représentant l'absence de valeur.
Optional.of(value) : Crée un Optional contenant une valeur non nulle.
Optional.ofNullable(value) : Crée un Optional qui peut contenir une valeur ou être vide (si la valeur est null).
isPresent() : Vérifie si l'Optional contient une valeur.
ifPresent(consumer) : Exécute une action si une valeur est présente.
orElse(defaultValue) : Retourne la valeur présente ou une valeur par défaut si l'Optional est vide.
orElseGet(supplier) : Semblable à orElse, mais prend un fournisseur pour retourner une valeur par défaut uniquement si l'Optional est vide.
get() : Récupère la valeur présente de l'Optional (lance une exception NoSuchElementException si l'Optional est vide).

## Pour tester les points de terminaison avec Postman

voici les étapes à suivre :

### 1. **Tester `GET /produits`**

Cette méthode récupère la liste de tous les produits.

- **Méthode** : `GET`
- **URL** : `http://localhost:8080/produits` (ou l'URL de votre serveur si différent)
- **Réponse attendue** : Une liste d'objets `ProduitDTO` en format JSON.
- **Étapes** :
  1. Ouvrir Postman.
  2. Sélectionner la méthode `GET`.
  3. Entrer l'URL `http://localhost:8080/produits`.
  4. Cliquer sur "Send".
  5. Vérifiez la réponse, qui devrait être une liste de produits en JSON.

### 2. **Tester `GET /produit/{id}`**

Cette méthode récupère un produit spécifique en fonction de son `id`.

- **Méthode** : `GET`
- **URL** : `http://localhost:8080/produit/{id}` (remplacer `{id}` par un ID réel, par exemple `1`)
- **Réponse attendue** : Un objet `ProduitDTO` en format JSON avec les détails du produit.
- **Étapes** :
  1. Sélectionner la méthode `GET`.
  2. Remplacer l'URL par `http://localhost:8080/produit/1` (en utilisant un `id` valide).
  3. Cliquer sur "Send".
  4. Vérifiez la réponse, qui devrait être un objet JSON représentant un produit.

### 3. **Tester `POST /produit`**

Cette méthode ajoute un nouveau produit.

- **Méthode** : `POST`
- **URL** : `http://localhost:8080/produit`
- **Corps de la requête** : JSON représentant le produit à ajouter. Par exemple :

```json
{
  "nom": "Produit Test",
  "prix": 19.99,
  "description": "Description du produit test"
}
```

- **Réponse attendue** : Un objet `ProduitDTO` en JSON avec les détails du produit ajouté, incluant l'ID généré.
- **Étapes** :
  1. Sélectionner la méthode `POST`.
  2. Entrer l'URL `http://localhost:8080/produit`.
  3. Sélectionner l'onglet "Body" dans Postman.
  4. Choisir l'option `raw` et définir le type comme `JSON`.
  5. Ajouter le JSON du produit à tester dans le corps de la requête.
  6. Cliquer sur "Send".
  7. Vérifiez la réponse, qui devrait être un objet JSON représentant le produit ajouté.

### 4. **Tester `PUT /produit/{id}`**

Cette méthode modifie un produit existant en fonction de son `id`.

- **Méthode** : `PUT`
- **URL** : `http://localhost:8080/produit/{id}` (remplacer `{id}` par un ID valide, par exemple `1`)
- **Corps de la requête** : JSON représentant le produit avec les nouvelles données. Par exemple :

```json
{
  "nom": "Produit Modifié",
  "prix": 29.99,
  "description": "Description modifiée du produit"
}
```

- **Réponse attendue** : Un objet `ProduitDTO` en JSON avec les détails du produit modifié.
- **Étapes** :
  1. Sélectionner la méthode `PUT`.
  2. Entrer l'URL `http://localhost:8080/produit/1` (en utilisant un `id` valide).
  3. Sélectionner l'onglet "Body" dans Postman.
  4. Choisir l'option `raw` et définir le type comme `JSON`.
  5. Ajouter le JSON représentant les nouvelles données du produit dans le corps de la requête.
  6. Cliquer sur "Send".
  7. Vérifiez la réponse, qui devrait être un objet JSON représentant le produit mis à jour.

### 5. **Tester `DELETE /produit/{id}`**

Cette méthode supprime un produit en fonction de son `id`.

- **Méthode** : `DELETE`
- **URL** : `http://localhost:8080/produit/{id}` (remplacer `{id}` par un ID valide, par exemple `1`)
- **Réponse attendue** : Un statut `200 OK` ou `204 No Content` en cas de suppression réussie.
- **Étapes** :
  1. Sélectionner la méthode `DELETE`.
  2. Entrer l'URL `http://localhost:8080/produit/1` (en utilisant un `id` valide).
  3. Cliquer sur "Send".
  4. Vérifiez la réponse, qui devrait être un statut de succès comme `200 OK` ou `204 No Content`.

### Autres vérifications

- **En-têtes** : Assurez-vous que le type de contenu est défini correctement dans les en-têtes HTTP, par exemple `Content-Type: application/json` pour les requêtes `POST` et `PUT`.
- **Authentification** : Si des mesures de sécurité comme l'authentification par token ou session sont en place, n'oubliez pas de fournir le token dans les en-têtes (`Authorization: Bearer {token}`).

Une fois que vous avez testé ces points de terminaison avec Postman, vous pourrez vérifier si les API fonctionnent comme prévu et si elles renvoient les bonnes réponses.
